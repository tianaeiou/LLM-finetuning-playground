# %%
import os
import sys
import pickle
import random
import json
from tdc.benchmark_group import admet_group
from benchmark.utils import normalize, get_min_max_value
from rdkit import Chem
from rdkit.Chem import AllChem, DataStructs, Descriptors, Lipinski
from instruction_tuning.instruction_prompt import *

sys.path.append("..")

project_path = "/home/wangtian/codeSpace/LLM-finetuning-playground"


def calculate_similarity(data_df, ref_df, file_dir, N=10):
    """ Calculate the similarity between molecules in test data and reference data, save the most similar N neighbors.

    For each data in test data, search for the most similar N neighbors from reference data and save the result to file_dir.
    If the result already exists, load it.

    :param data_df: DataFrame containing the test data
    :param ref_df: DataFrame containing the reference data
    :param file_dir: Directory to save the neighbor information.
    :param N: Number of neighbors to find for each molecule.
    :return: Dictionary containing SMILES for test data and neighbor_index
    """
    # Check if the result file exists
    if os.path.isfile(file_dir):
        with open(file_dir, 'rb') as file:
            try:
                neighbor_dict = pickle.load(file)
                print("Neighbor info loaded!")
                return neighbor_dict
            except Exception as e:
                print(f"Failed to load neighbor info: {e}")

    # Calculate similarity
    smiles_list_test, smiles_list_ref = data_df["Drug"].to_list(), ref_df["Drug"].to_list()
    molecules_test = [Chem.MolFromSmiles(smiles) for smiles in smiles_list_test]
    molecules_ref = [Chem.MolFromSmiles(smiles) for smiles in smiles_list_ref]
    fps_test = [AllChem.GetMorganFingerprintAsBitVect(m, radius=2) for m in molecules_test]
    fps_ref = [AllChem.GetMorganFingerprintAsBitVect(m, radius=2) for m in molecules_ref]
    nearest_neighbors = {i: [] for i in range(len(smiles_list_test))}
    for i, fp1 in enumerate(fps_test):
        for j, fp2 in enumerate(fps_ref):
            if fp1 != fp2:
                similarity = DataStructs.FingerprintSimilarity(fp1, fp2)
                if len(nearest_neighbors[i]) < N:
                    nearest_neighbors[i].append((j, similarity))
                else:
                    nearest_neighbors[i].append((j, similarity))
                    nearest_neighbors[i].sort(key=lambda x: x[1], reverse=True)
                    nearest_neighbors[i] = nearest_neighbors[i][:N]
    result = {"smiles": smiles_list_test, "neighbor_index": nearest_neighbors}

    # Save to file_dir
    os.makedirs(os.path.dirname(file_dir), exist_ok=True)
    with open(file_dir, 'wb') as f:
        pickle.dump(result, f)
    return result

def get_property_description(mol, digit=3):
    """Generate a description of the molecular properties for a given RDKit molecule.

    :param mol: RDKit Mol object for which to calculate properties.
    :param digit: Number of decimal places to round the property values to.
    :return: String of property description, which can be inserted in the prompt
    """
    if mol is None:
        return {
            "MW": "undefined",
            "CLogP": "undefined",
            "HBD": "undefined",
            "HBA": "undefined",
            "RB": "undefined",
            "TPSA": "undefined"
        }
    property_dict = {
        "MW": round(Descriptors.MolWt(mol), digit),
        "CLogP": round(Descriptors.MolLogP(mol), digit),
        "HBD": Lipinski.NumHDonors(mol),
        "HBA": Lipinski.NumHAcceptors(mol),
        "RB": Lipinski.NumRotatableBonds(mol),
        "TPSA": round(Descriptors.TPSA(mol), digit)
    }
    property_prompt = ""
    for property_name, property_value in property_dict.items():
        property_prompt += PROPERTIES_TEMPLATES[property_name].format(value=property_value)
    return property_prompt


def get_example_prompt(cur_neighbor_dict, num_examples, data_index, ref_df, min_value=0, max_value=1,
                       is_regression_task=True, example_template=EXAMPLE_TEMPLATE, use_property=False,
                       property_template=EXAMPLE_TEMPLATE_PROPERTY):
    """ Generate prompt for k-shot prompting.

    :param cur_neighbor_dict: Dictionary containing neighbor info, generated by calculate_similarity.
    :param num_examples: Number of examples to include in the prompt.
    :param data_index: index used to get neighbor info from cur_neighbor_dict.
    :param ref_df: DataFrame containing reference data.
    :param min_value: Minimum value for normalization in regression tasks.
    :param max_value: Maximum value for normalization in regression tasks.
    :param is_regression_task: Boolean indicating if the task is a regression task.
    :param example_template: Template for the example prompt.
    :param use_property: Boolean indicating if to add properties (ruleof5) in the prompt.
    :param property_template: Template for example prompt with properties.
    :return: A string containing the example prompt.
    """
    example_prompt = ""
    for j in range(num_examples):
        neighbor_idx = cur_neighbor_dict["neighbor_index"][data_index][j][0]
        mol = Chem.MolFromSmiles(ref_df["Drug"].to_list()[neighbor_idx])
        neighbor_smiles = Chem.MolToSmiles(mol)
        if is_regression_task:
            neighbor_target = normalize(ref_df["Y"].to_list()[neighbor_idx], min_value, max_value)
        else:
            neighbor_target = int(ref_df["Y"].to_list()[neighbor_idx])
        if use_property:
            cur_example = property_template.format(CUR_ANSWER=neighbor_target, CUR_DRUG_SMILES=str(neighbor_smiles),
                                                   CUR_DRUG_PROPERTIES=get_property_description(mol))
        else:
            cur_example = example_template.format(CUR_ANSWER=neighbor_target, CUR_DRUG_SMILES=str(neighbor_smiles))
        example_prompt += cur_example
    return example_prompt


def create_prompt_for_single_row(row, example_prompt, instruction_description, context_description, predict_target_name,
                                 min_value=0, max_value=1, is_regression_task=True, label0_description="",
                                 label1_description="",
                                 reg_template_with_example=PROMPT_TEMPLATE_REG_WITH_EXAMPLE,
                                 reg_template_with_example_property=PROMPT_TEMPLATE_REG_WITH_EXAMPLE_PROPERTY,
                                 reg_template=PROMPT_TEMPLATE_REG,
                                 cls_template_with_example=PROMPT_TEMPLATE_CLS_WITH_EXAMPLE_TxLLM,
                                 cls_template_with_example_property=PROMPT_TEMPLATE_CLS_WITH_EXAMPLE_TxLLM_PROPERTY,
                                 cls_template=PROMPT_TEMPLATE_CLS_TxLLM, use_property=False):
    """ Generate prompt for a single row

    param row: Dictionary or Series containing data for a single row.
    :param example_prompt: Prompt for k-shot example; empty string for zero-shot scenario.
    :param instruction_description: Dataset-specific instruction.
    :param context_description: Dataset-specific context.
    :param predict_target_name: Target variable name for prediction.
    :param min_value: Minimum value for normalization in regression tasks.
    :param max_value: Maximum value for normalization in regression tasks.
    :param is_regression_task: Boolean indicating if the task is a regression task.
    :param label0_description: For target task, the description for label 0.
    :param label1_description: For target task, the description for label 1.
    :param reg_template_with_example: Few-shot regression template.
    :param reg_template: Zero-shot regression template.
    :param cls_template_with_example: Few-shot classification template.
    :param cls_template: Zero-shot classification template.
    :param use_property: Boolean indicating if to add properties (ruleof5) in the prompt.
    :return: Dictionary containing system, instruction, input, and output.
    """
    mol = Chem.MolFromSmiles(row["Drug"])
    property_description = ""

    if is_regression_task:
        if example_prompt:
            if use_property:
                template = reg_template_with_example_property
                property_description = get_property_description(mol)
            else:
                template = reg_template_with_example
        else:
            template = reg_template
        processed_output = str(normalize(row["Y"], min_value, max_value))
        cur_input = template.format(CUR_CONTEXT_INFO=context_description, CUR_DRUG_SMILES=Chem.MolToSmiles(mol),
                                    CUR_TARGET=predict_target_name, CUR_EXAMPLES=example_prompt,
                                    CUR_DRUG_PROPERTIES=property_description)
    else:
        if example_prompt:
            if use_property:
                template = cls_template_with_example_property
                property_description = get_property_description(mol)
            else:
                template = cls_template_with_example
        else:
            template = cls_template

        processed_output = str(row["Y"])
        cur_input = template.format(CUR_CONTEXT_INFO=context_description, CUR_DRUG_SMILES=Chem.MolToSmiles(mol),
                                    CUR_TARGET=predict_target_name, CUR_EXAMPLES=example_prompt,
                                    LABEL0_DESCRIPTION=label0_description, LABEL1_DESCRIPTION=label1_description,
                                    CUR_DRUG_PROPERTIES=property_description)
    return {
        "system": SYSTEM_INSTRUCTION,
        "instruction": instruction_description,
        "input": cur_input,
        "output": processed_output
    }


def generate_hybrid_instruction(data_df, ref_df, instruction_description, context_description, predict_target_name,
                                neighbor_dict, min_value=0, max_value=1, is_regression_task=True, label0_description="",
                                label1_description="", use_property=False):
    """ Generate prompt in hybrid instruction strategy (70% zero-shot + 30% 1-5-shot).

    :param data_df: DataFrame containing the test data
    :param ref_df: DataFrame containing the reference data
    :param instruction_description: Dataset-specific instruction.
    :param context_description: Dataset-specific context.
    :param predict_target_name: Target variable name for prediction.
    :param neighbor_dict: Neighbor info.
    :param min_value: Minimum value for normalization in regression tasks.
    :param max_value: Maximum value for normalization in regression tasks.
    :param is_regression_task: Boolean indicating if the task is a regression task.
    :param label0_description: For target task, the description for label 0.
    :param label1_description: For target task, the description for label 1.
    :param use_property: Boolean indicating if to add properties (ruleof5) in the prompt.
    :return: List of prompts for the data_df.
    """

    # Determine mixed-few-shot sample indices
    zero_shot_nums = int(len(data_df) * 0.7)
    mixed_few_shot_nums = len(data_df) - zero_shot_nums
    mixed_few_shot_idx = random.sample(range(len(data_df)), mixed_few_shot_nums)

    # Generate prompt
    prompts_list = []
    for idx, row in data_df.iterrows():
        cur_k = random.randint(1, 5) if idx in mixed_few_shot_idx else 0
        example_prompt = get_example_prompt(neighbor_dict, cur_k, idx, ref_df, min_value, max_value,
                                            is_regression_task=False, use_property=use_property)
        cur_prompt = create_prompt_for_single_row(row, example_prompt, instruction_description, context_description,
                                                  predict_target_name, min_value, max_value,
                                                  is_regression_task=is_regression_task,
                                                  label0_description=label0_description,
                                                  label1_description=label1_description, use_property=use_property)
        prompts_list.append(cur_prompt)
    return prompts_list


def process_dataset(data_df, ref_df, dataset_name, neighbor_info_dir, k, use_hybrid, use_property):
    """

    :param data_df: DataFrame containing the test data.
    :param ref_df: DataFrame containing the reference data.
    :param dataset_name: Name of the SFT_dataset.
    :param neighbor_info_dir: Path to Neighbor info file.
    :param k: k=0 for zero-shot instruction strategy, k>0 for few-shot instruction strategy.
    :param use_hybrid: Boolean indicating if to use hybrid instruction strategy.
    :param use_property: Boolean indicating if to add properties (ruleof5) in the prompt.
    :return:
    """
    instruction_prompt = INSTRUCTION[dataset_name]
    context_prompt = CONTEXT[dataset_name]
    target_prompt = QUESTION[dataset_name]["target"]

    if dataset_name in REGRESSION_TASKS:
        label0_description, label1_description = "", ""
        min_value, max_value = get_min_max_value(data_df)
        is_regression_task = True
    else:
        label0_description, label1_description = QUESTION[dataset_name]["label0"], QUESTION[dataset_name]["label1"]
        min_value, max_value = 0, 1
        is_regression_task = False

    neighbor_dict = calculate_similarity(data_df, ref_df, neighbor_info_dir)
    if use_hybrid:
        prompts_list = generate_hybrid_instruction(data_df, ref_df, instruction_prompt, context_prompt, target_prompt,
                                                   neighbor_dict, min_value=min_value, max_value=max_value,
                                                   is_regression_task=is_regression_task,
                                                   label0_description=label0_description,
                                                   label1_description=label1_description, use_property=use_property)
    else:
        prompts_list = []
        for idx, row in data_df.iterrows():
            example_prompt = get_example_prompt(neighbor_dict, k, idx, ref_df, min_value=min_value, max_value=max_value,
                                                is_regression_task=is_regression_task, use_property=use_property)
            cur_prompt = create_prompt_for_single_row(row, example_prompt, instruction_prompt, context_prompt,
                                                      target_prompt, min_value=min_value, max_value=max_value,
                                                      is_regression_task=is_regression_task,
                                                      label0_description=label0_description,
                                                      label1_description=label1_description, use_property=use_property)
            prompts_list.append(cur_prompt)
    return prompts_list


# %%
"""
setting
"""
k = 2  # 5
mode = "test"  # mode = "train"  # only using train_val_df ["train", "test"]
save_dir = f"{project_path}/instruction_tuning/test_instructions/cls_v1/5-shot"
use_hybrid = False
use_property = False

"""
# step 0: generate neighbor_info for all dataset : f"{project_path}/instruction_tuning/neighbor_info/{dataset}-neighbors-{mode}.pkl"

group = admet_group(path='data/')
save_dir = "/home/wangtian/codeSpace/LLM-finetuning-playground/instruction_tuning/neighbor_info"
import os

existing_files = os.listdir(save_dir)
for dataset in all_dataset:
    benchmark = group.get(dataset)
    train_val_df, test_df = benchmark['train_val'], benchmark['test']
    for mode in ["train", "test"]:
        file_name = f"{dataset}-neighbors-{mode}.pkl"
        if file_name not in existing_files:
            print(file_name)
            if mode == "train":
                ref_df = train_val_df
                data_df = train_val_df
            else:
                ref_df = train_val_df
                data_df = test_df
            neighbor_dict = calculate_similarity(data_df, ref_df,
                                                 f"{project_path}/instruction_tuning/neighbor_info/{dataset}-neighbors-{mode}.pkl")
            print(f"{project_path}/instruction_tuning/neighbor_info/{dataset}-neighbors-{mode}.pkl, Done!")
"""
prompts_all = []
group = admet_group(path='data/')
for dataset in CLASSIFICATION_TASKS:
    benchmark = group.get(dataset)
    train_val_df, test_df = benchmark['train_val'], benchmark['test']
    if mode == "train":
        ref_df = train_val_df
        data_df = train_val_df
    else:
        ref_df = train_val_df
        data_df = test_df
    print(f"Dataset: {dataset}, Mode: {mode}, Size: {len(data_df)}")
    file_name = f"{dataset}_instruction-{k}-shot-{mode}.json" if not use_hybrid else f"{dataset}_instruction-mixed-{mode}.json"
    neighbor_info_dir = f"{project_path}/instruction_tuning/neighbor_info/{dataset}-neighbors-{mode}.pkl"
    prompts_list = process_dataset(data_df, ref_df, dataset, neighbor_info_dir, k=k, use_hybrid=use_hybrid,
                                   use_property=use_property)
    prompts_all.extend(prompts_list)
    with open(f"{save_dir}/{file_name}", 'w') as json_file:
        json.dump(prompts_list, json_file)
    print(f"{save_dir}/{file_name}, Done!")

# print(f"whole dataset length: {len(prompts_all)}")
# with open(f"{project_path}/instruction_tuning/instructions/classification_all-1-shot_v1.json", 'w') as json_file:
#     json.dump(prompts_all, json_file)
# print(prompts_list[0]["input"])
